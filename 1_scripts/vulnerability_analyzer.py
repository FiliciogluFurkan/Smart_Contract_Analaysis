"""
Smart Contract Vulnerability Analyzer - NLP Based
Kontrat kodlarını analiz edip vulnerability pattern'leri tespit eder
"""

import json
import pandas as pd
import re
from collections import defaultdict

class VulnerabilityAnalyzer:
    def __init__(self):
        # Vulnerability patterns yükle
        with open('vulnerability_patterns.json', 'r', encoding='utf-8') as f:
            self.patterns = json.load(f)
        
        self.results = []
    
    def analyze_reentrancy(self, code):
        """Reentrancy vulnerability kontrolü"""
        findings = []
        
        # call.value pattern'i ara
        if re.search(r'\.call\.value\(.*?\)\(.*?\)', code, re.IGNORECASE):
            findings.append({
                'type': 'reentrancy',
                'severity': 'HIGH',
                'pattern': 'call.value() detected',
                'description': 'External call with value transfer - potential reentrancy risk'
            })
        
        # call() kullanımı
        if re.search(r'\.call\(', code):
            findings.append({
                'type': 'reentrancy',
                'severity': 'MEDIUM',
                'pattern': '.call() usage',
                'description': 'Low-level call detected - check for reentrancy protection'
            })
        
        return findings
    
    def analyze_tx_origin(self, code):
        """tx.origin kullanımı kontrolü"""
        findings = []
        
        if re.search(r'tx\.origin', code, re.IGNORECASE):
            findings.append({
                'type': 'tx_origin',
                'severity': 'HIGH',
                'pattern': 'tx.origin authentication',
                'description': 'tx.origin used - vulnerable to phishing attacks'
            })
        
        return findings
    
    def analyze_delegatecall(self, code):
        """delegatecall vulnerability kontrolü"""
        findings = []
        
        if re.search(r'delegatecall\(', code, re.IGNORECASE):
            findings.append({
                'type': 'delegatecall',
                'severity': 'HIGH',
                'pattern': 'delegatecall usage',
                'description': 'Delegatecall to untrusted contract can hijack storage'
            })
        
        return findings
    
    def analyze_selfdestruct(self, code):
        """selfdestruct kontrolü"""
        findings = []
        
        if re.search(r'selfdestruct\(|suicide\(', code, re.IGNORECASE):
            findings.append({
                'type': 'selfdestruct',
                'severity': 'CRITICAL',
                'pattern': 'selfdestruct/suicide',
                'description': 'Contract can be destroyed - check access control'
            })
        
        return findings
    
    def analyze_unchecked_send(self, code):
        """Unchecked return value kontrolü"""
        findings = []
        
        # send() without checking return
        if re.search(r'\.send\([^;]+\);(?!\s*require)', code):
            findings.append({
                'type': 'unchecked_return',
                'severity': 'MEDIUM',
                'pattern': 'unchecked send()',
                'description': 'send() return value not checked'
            })
        
        return findings
    
    def analyze_overflow(self, code):
        """Integer overflow/underflow kontrolü"""
        findings = []
        
        # SafeMath kullanımı kontrol et
        has_safemath = 'SafeMath' in code or 'using SafeMath' in code
        
        # Solidity version kontrol
        version_match = re.search(r'pragma solidity\s+[^\d]*(\d+\.\d+\.\d+)', code)
        if version_match:
            version = version_match.group(1)
            major, minor, patch = map(int, version.split('.'))
            
            # Solidity 0.8.0 öncesi overflow kontrolü yok
            if (major == 0 and minor < 8) and not has_safemath:
                # Aritmetik işlemler var mı?
                if re.search(r'\+|\-|\*|/', code):
                    findings.append({
                        'type': 'overflow',
                        'severity': 'HIGH',
                        'pattern': 'no overflow protection',
                        'description': f'Solidity {version} without SafeMath - overflow risk'
                    })
        
        return findings
    
    def analyze_access_control(self, code):
        """Access control kontrolü"""
        findings = []
        
        # onlyOwner modifier var mı?
        has_access_control = bool(re.search(r'onlyOwner|onlyAdmin|auth|require\(msg\.sender\s*==', code))
        
        # Critical fonksiyonlar
        critical_functions = ['selfdestruct', 'delegatecall', 'transfer', 'withdraw']
        
        for func in critical_functions:
            if func in code.lower() and not has_access_control:
                findings.append({
                    'type': 'access_control',
                    'severity': 'HIGH',
                    'pattern': f'unprotected {func}',
                    'description': f'Critical function "{func}" may lack access control'
                })
                break  # Bir kere uyarı yeter
        
        return findings
    
    def calculate_risk_score(self, findings):
        """Risk skoru hesapla (0-100)"""
        severity_scores = {
            'CRITICAL': 30,
            'HIGH': 20,
            'MEDIUM': 10,
            'LOW': 5
        }
        
        total_score = sum(severity_scores.get(f['severity'], 0) for f in findings)
        return min(total_score, 100)  # Max 100
    
    def analyze_contract(self, contract_data):
        """Tek bir kontratı analiz et"""
        address = contract_data.get('address', 'Unknown')
        name = contract_data.get('name', 'Unknown')
        code = contract_data.get('source_code', '')
        category = contract_data.get('category', 'unknown')
        
        print(f"\n{'='*60}")
        print(f"🔍 Analyzing: {name}")
        print(f"📍 Address: {address[:20]}...")
        print(f"🏷️  Category: {category.upper()}")
        print(f"{'='*60}")
        
        if not code or code == '':
            print("⚠️  No source code available")
            return {
                'address': address,
                'name': name,
                'category': category,
                'vulnerabilities': [],
                'risk_score': 0,
                'analysis_status': 'no_source_code'
            }
        
        # Tüm analizleri çalıştır
        all_findings = []
        all_findings.extend(self.analyze_reentrancy(code))
        all_findings.extend(self.analyze_tx_origin(code))
        all_findings.extend(self.analyze_delegatecall(code))
        all_findings.extend(self.analyze_selfdestruct(code))
        all_findings.extend(self.analyze_unchecked_send(code))
        all_findings.extend(self.analyze_overflow(code))
        all_findings.extend(self.analyze_access_control(code))
        
        # Risk skoru hesapla
        risk_score = self.calculate_risk_score(all_findings)
        
        # Sonuçları göster
        if all_findings:
            print(f"\n⚠️  Found {len(all_findings)} potential vulnerabilities:")
            for finding in all_findings:
                severity_emoji = {
                    'CRITICAL': '🔴',
                    'HIGH': '🟠',
                    'MEDIUM': '🟡',
                    'LOW': '🟢'
                }
                emoji = severity_emoji.get(finding['severity'], '⚪')
                print(f"  {emoji} [{finding['severity']}] {finding['type']}: {finding['pattern']}")
        else:
            print("\n✅ No obvious vulnerabilities detected")
        
        print(f"\n📊 Risk Score: {risk_score}/100")
        
        result = {
            'address': address,
            'name': name,
            'category': category,
            'vulnerabilities': all_findings,
            'risk_score': risk_score,
            'analysis_status': 'completed',
            'vulnerability_count': len(all_findings)
        }
        
        self.results.append(result)
        return result
    
    def analyze_all(self, dataset_file='final_dataset.json'):
        """Tüm kontratları analiz et"""
        print("🚀 Starting vulnerability analysis...")
        print(f"📂 Loading dataset: {dataset_file}\n")
        
        with open(dataset_file, 'r', encoding='utf-8') as f:
            contracts = json.load(f)
        
        print(f"📊 Total contracts to analyze: {len(contracts)}\n")
        
        for contract in contracts:
            self.analyze_contract(contract)
        
        # Sonuçları kaydet
        self.save_results()
        self.generate_report()
    
    def save_results(self):
        """Analiz sonuçlarını kaydet"""
        with open('vulnerability_analysis_results.json', 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)
        
        df = pd.DataFrame(self.results)
        df.to_csv('vulnerability_analysis_results.csv', index=False)
        
        print("\n" + "="*60)
        print("💾 Results saved:")
        print("   📄 vulnerability_analysis_results.json")
        print("   📄 vulnerability_analysis_results.csv")
    
    def generate_report(self):
        """Özet rapor oluştur"""
        df = pd.DataFrame(self.results)
        
        report = f"""
╔══════════════════════════════════════════════════════════════╗
║          VULNERABILITY ANALYSIS REPORT                       ║
╚══════════════════════════════════════════════════════════════╝

📊 OVERALL STATISTICS
{'─'*60}
Total Contracts Analyzed: {len(self.results)}
Contracts with Source Code: {len(df[df['analysis_status'] == 'completed'])}
Contracts without Source Code: {len(df[df['analysis_status'] == 'no_source_code'])}

🎯 VULNERABILITY SUMMARY
{'─'*60}
Total Vulnerabilities Found: {df['vulnerability_count'].sum()}
Average Vulnerabilities per Contract: {df['vulnerability_count'].mean():.2f}
Average Risk Score: {df['risk_score'].mean():.1f}/100

📈 RISK DISTRIBUTION
{'─'*60}
"""
        
        # Risk kategorileri
        risk_categories = {
            'Critical (80-100)': len(df[df['risk_score'] >= 80]),
            'High (60-79)': len(df[(df['risk_score'] >= 60) & (df['risk_score'] < 80)]),
            'Medium (40-59)': len(df[(df['risk_score'] >= 40) & (df['risk_score'] < 60)]),
            'Low (20-39)': len(df[(df['risk_score'] >= 20) & (df['risk_score'] < 40)]),
            'Safe (0-19)': len(df[df['risk_score'] < 20])
        }
        
        for category, count in risk_categories.items():
            percentage = (count / len(df)) * 100 if len(df) > 0 else 0
            report += f"{category:<20} : {count:>3} ({percentage:>5.1f}%)\n"
        
        # En riskli kontratlar
        top_risky = df.nlargest(5, 'risk_score')[['name', 'category', 'risk_score', 'vulnerability_count']]
        
        report += f"""
{'─'*60}
🔴 TOP 5 RISKY CONTRACTS
{'─'*60}
"""
        for idx, row in top_risky.iterrows():
            report += f"{row['name']:<25} | Score: {row['risk_score']:>3} | Vulns: {row['vulnerability_count']}\n"
        
        # Vulnerability type distribution
        vuln_types = defaultdict(int)
        for result in self.results:
            for vuln in result.get('vulnerabilities', []):
                vuln_types[vuln['type']] += 1
        
        if vuln_types:
            report += f"""
{'─'*60}
🔍 VULNERABILITY TYPES FOUND
{'─'*60}
"""
            for vuln_type, count in sorted(vuln_types.items(), key=lambda x: x[1], reverse=True):
                report += f"{vuln_type:<25} : {count:>3}\n"
        
        report += f"""
{'─'*60}

✅ Analysis completed successfully!
"""
        
        print(report)
        
        with open('vulnerability_report.txt', 'w', encoding='utf-8') as f:
            f.write(report)
        
        print("📄 Report saved: vulnerability_report.txt")

if __name__ == "__main__":
    analyzer = VulnerabilityAnalyzer()
    analyzer.analyze_all()